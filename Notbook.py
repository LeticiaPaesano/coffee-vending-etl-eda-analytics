# -*- coding: utf-8 -*-
"""Untitled9.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1gvVCbxCUXAr3xEQ_Jgkr-8XTwVCyYeDa
"""

# Bibliotecas
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from datetime import datetime, timedelta
import matplotlib.patches as mpatches
from matplotlib.gridspec import GridSpec

# Configura√ß√£o visual
plt.style.use('seaborn-v0_8-darkgrid')
COFFEE_PALETTE = ['#6F4E37', '#A0522D', '#8B7355', '#D2B48C', '#BC8F8F', '#4E3629', '#3E2723']
sns.set_palette(COFFEE_PALETTE)

"""# ‚òï An√°lise vendas de caf√© (m√°quina autom√°tica)

## üìå Contextualiza√ß√£o do Projeto

* **Per√≠odo analisado** 01/03/2024 a 17/07/2024
* **Localiza√ß√£o** Ucr√¢nia (GMT+2)        
* **Moeda** Hryvnia Ucraniana (UAH)
* **Volume total de vendas** 976 transa√ß√µes  

---

## üóÇÔ∏è Dicion√°rio de Dados (ap√≥s tratamento)

| Campo            | Descri√ß√£o                 |
|------------------|---------------------------|
|`date`            | Data da compra            |
|`datetime`        | Data e hora completa      |
|`hour`            | Hor√°rio da compra (HH:MM) |
|`tipo_pagamento`  | Cart√£o ou dinheiro        |
|`valor_hryvnia`   | Valor pago (UAH)          |
|`coffee_name`     | Tipo de caf√©              |
|`dia_semana`      | Nome do dia da semana     |
|`mes`             | Nome do m√™s               |
|`ano`             | Ano da venda              |
|`hora_numerica`   | Hora como n√∫mero (0‚Äì23)   |
|`semana_ano`      | Semana do ano             |
|`dia_mes`         | Dia do m√™s                |
## üéØ Objetivos do Projeto

* **Otimiza√ß√£o do mix de produtos** Identifica√ß√£o dos itens mais rent√°veis via Curva ABC                       
* **Gest√£o operacional**   Identifica√ß√£o de hor√°rios/dias de pico para aloca√ß√£o eficiente de recursos
* **Aprimoramento Financeiro** Ticket m√©dio, receita, volume de vendas, meios de pagamento                
* **Previs√£o de Demanda** Fundamentos para modelagem preditiva e planejamento inteligente de estoque


## üõ†Ô∏è Metodologia Aplicada


 **ETL & Feature Engineering**: Extra√ß√£o de CSV, transforma√ß√£o temporal, deriva√ß√£o de vari√°veis (hora, dia_semana, m√™s, tipo_pagamento), normaliza√ß√£o e tratamento de sensibilidades | *`vendas_cafe_tratado.xlsx` / `.csv`*

**An√°lise Explorat√≥ria (EDA)**: Agrega√ß√µes multidimensionais por produto/per√≠odo/pagamento, estat√≠sticas descritivas (sum, count, mean), identifica√ß√£o de padr√µes | *Profiling de dados*

**An√°lise de Pareto (ABC)**: Segmenta√ß√£o por rentabilidade: Classe A (78,5%), B (15,5%), C (6,0%) | *Classifica√ß√£o estrat√©gica*

**Sazonalidade Temporal**: √çndices sazonais por dia/m√™s, decomposi√ß√£o de per√≠odos (manh√£ 27,9%, tarde 42,8%, noite 29,3%), impacto de 7 feriados | *√çndices sazonais + calend√°rio*

**S√©rie Temporal**: Evolu√ß√£o mensal com taxa de crescimento (+5,3% m√©dia, ¬±34,9% volatilidade), tend√™ncias com base 100 (Mar√ßo) | *Matriz temporal de tend√™ncias *

**Visualiza√ß√µes & Benchmarking**: 6 gr√°ficos (pizza, barras, dual-axis, linhas, Gantt), compara√ß√µes feriados/normais, segmentos, per√≠odos |* 6 visualiza√ß√µes anal√≠ticas*

**An√°lise de Impacto**: Quantifica√ß√£o de riscos (feriados -96,4%, POS 90,4%, ticket cash +6,3%) e oportunidades | *Matriz de risco/oportunidade*

# 1. CARREGAMENTO E PR√â-PROCESSAMENTO DOS DADOS
"""

# Carregar dataset original
df = pd.read_csv('/content/venda-cafe.csv.csv')
print(f"‚úì Dataset original carregado: {len(df):,} registros")

# Converter colunas de data/hora
df['datetime'] = pd.to_datetime(df['datetime'])
df['date'] = pd.to_datetime(df['date'])

# Filtrar per√≠odo de an√°lise (at√© 17/07/2024)
df = df[df['date'] <= '2024-07-17'].copy()
print(f"‚úì Dados filtrados (at√© 17/07/2024): {len(df):,} registros")

"""# 2. ENGENHARIA DE FEATURES

"""

# Feature: Hora formatada (HH:MM)
df['hour'] = df['datetime'].dt.strftime('%H:%M')
df['hora_numerica'] = df['datetime'].dt.hour

# Feature: Tipo de pagamento (tradu√ß√£o)
df['tipo_pagamento'] = df['cash_type'].map({'card': 'Cart√£o', 'cash': 'Dinheiro'})

# Feature: Valor em UAH (renomea√ß√£o para clareza)
df['valor_hryvnia'] = df['money']

# Features temporais (calend√°rio ucraniano - GMT+2)
df['dia_semana_num'] = df['date'].dt.dayofweek  # 0=Segunda, 6=Domingo
df['dia_semana'] = df['date'].dt.day_name().map({
    'Monday': 'Segunda-feira', 'Tuesday': 'Ter√ßa-feira',
    'Wednesday': 'Quarta-feira', 'Thursday': 'Quinta-feira',
    'Friday': 'Sexta-feira', 'Saturday': 'S√°bado', 'Sunday': 'Domingo'
})

df['mes_num'] = df['date'].dt.month
df['mes'] = df['date'].dt.month_name().map({
    'January': 'Janeiro', 'February': 'Fevereiro', 'March': 'Mar√ßo',
    'April': 'Abril', 'May': 'Maio', 'June': 'Junho', 'July': 'Julho'
})

df['ano'] = df['date'].dt.year
df['semana_ano'] = df['date'].dt.isocalendar().week
df['dia_mes'] = df['date'].dt.day

# Remover coluna de identifica√ß√£o de cart√£o
df_tratado = df.drop(columns=['card', 'cash_type', 'money'])

print("‚úì Features criadas:")
print("  ‚Ä¢ hour (formato HH:MM)")
print("  ‚Ä¢ tipo_pagamento (Cart√£o/Dinheiro)")
print("  ‚Ä¢ dia_semana, mes (em portugu√™s)")
print("  ‚Ä¢ dia_semana_num, mes_num, semana_ano")
print("  ‚Ä¢ Coluna 'card' removida")

"""# 3. EXPORTA√á√ÉO DOS DADOS TRATADOS"""

# Reordenar colunas para melhor legibilidade
colunas_ordem = ['date', 'datetime', 'hour', 'tipo_pagamento', 'valor_hryvnia',
                 'coffee_name', 'dia_semana', 'dia_semana_num', 'mes', 'mes_num',
                 'ano', 'hora_numerica', 'semana_ano', 'dia_mes']
df_export = df_tratado[colunas_ordem]

# Exportar para m√∫ltiplos formatos
df_export.to_excel('vendas_cafe_tratado.xlsx', index=False, sheet_name='Vendas',
                   engine='openpyxl')
df_export.to_csv('vendas_cafe_tratado.csv', index=False, encoding='utf-8-sig')

print("‚úì Arquivos gerados:")
print("  ‚Ä¢ vendas_cafe_tratado.xlsx")
print("  ‚Ä¢ vendas_cafe_tratado.csv")

"""# 4. RESUMO EXECUTIVO - INDICADORES PRINCIPAIS

"""

# C√°lculo de KPIs prim√°rios
total_receita = df['valor_hryvnia'].sum()
total_transacoes = len(df)
ticket_medio = df['valor_hryvnia'].mean()
valor_minimo = df['valor_hryvnia'].min()
valor_maximo = df['valor_hryvnia'].max()
periodo_inicio = df['date'].min().strftime('%d/%m/%Y')
periodo_fim = df['date'].max().strftime('%d/%m/%Y')
dias_operacao = df['date'].nunique()

print("üìà INDICADORES-CHAVE DE PERFORMANCE (KPIs)")
print("‚ïê" * 70)
print(f"Per√≠odo de An√°lise     : {periodo_inicio} a {periodo_fim}")
print(f"Dias de Opera√ß√£o       : {dias_operacao} dias (com vendas)")
print(f"Total de Transa√ß√µes    : {total_transacoes:,} vendas")
print(f"Receita Total          : {total_receita:,.2f} UAH")
print(f"Ticket M√©dio           : {ticket_medio:.2f} UAH")
print(f"Ticket M√≠nimo          : {valor_minimo:.2f} UAH")
print(f"Ticket M√°ximo          : {valor_maximo:.2f} UAH")
print(f"Vendas/Dia (M√©dia)     : {total_transacoes/dias_operacao:.2f} vendas")
print(f"Receita/Dia (M√©dia)    : {total_receita/dias_operacao:.2f} UAH")

# Feriados do pa√≠s
feriados_map = {
    pd.to_datetime("2024-03-08").date(): "Dia Internacional da Mulher",
    pd.to_datetime("2024-05-01").date(): "Dia do Trabalhador",
    pd.to_datetime("2024-05-02").date(): "Dia do Trabalhador (cont.)",
    pd.to_datetime("2024-05-05").date(): "P√°scoa (Ortodoxa)",
    pd.to_datetime("2024-05-09").date(): "Dia da Vit√≥ria",
    pd.to_datetime("2024-06-23").date(): "Pentecostes",
    pd.to_datetime("2024-06-28").date(): "Dia da Constitui√ß√£o"
}

df_feriados = pd.DataFrame({
    "data": list(feriados_map.keys()),
    "feriado": list(feriados_map.values())
})
df_feriados['data'] = pd.to_datetime(df_feriados['data'])
print("\n‚úì DataFrame de feriados criado:")
print(df_feriados.to_string(index=False))

"""# 5. AN√ÅLISE POR M√âTODO DE PAGAMENTO"""

print("\n\nüí≥ AN√ÅLISE: M√âTODOS DE PAGAMENTO")
print("‚ïê" * 70)

for tipo in ['Cart√£o', 'Dinheiro']:
    dados_tipo = df[df['tipo_pagamento'] == tipo]
    qtd = len(dados_tipo)
    receita = dados_tipo['valor_hryvnia'].sum()
    ticket = dados_tipo['valor_hryvnia'].mean()
    perc_qtd = (qtd / total_transacoes) * 100
    perc_receita = (receita / total_receita) * 100

    print(f"\n{tipo}:")
    print(f"  ‚Ä¢ Transa√ß√µes    : {qtd:>5} ({perc_qtd:>5.1f}% do volume)")
    print(f"  ‚Ä¢ Receita       : {receita:>10,.2f} UAH ({perc_receita:>5.1f}% do total)")
    print(f"  ‚Ä¢ Ticket M√©dio  : {ticket:>10.2f} UAH")

rotulos = ['Cart√£o', 'Dinheiro']
tamanhos = [90.9, 9.1]
cores = ['#694C38', '#CBB490']

# Cria√ß√£o do Gr√°fico de Pizza
fig, ax = plt.subplots(figsize=(6, 6))

wedges, texts, autotexts = ax.pie(
    tamanhos,
    labels=rotulos,
    colors=cores,
    autopct='%1.1f%%',
    startangle=90,
    wedgeprops={'linewidth': 0}
)

# Ajuste do estilo do texto de porcentagem (dentro das fatias)
for autotext in autotexts:
    autotext.set_color('white')
    autotext.set_fontsize(12)
    autotext.set_fontweight('bold')

# Ajuste do estilo dos r√≥tulos (fora das fatias)
for text in texts:
    text.set_color('#363636')
    text.set_fontsize(14)
    text.set_fontweight('bold')

# T√≠tulo do Gr√°fico
ax.set_title('Distribui√ß√£o por M√©todo de Pagamento', fontsize=16, fontweight='bold',
             color='#363636')

# Configura√ß√µes adicionais
ax.axis('equal')
plt.show()

"""A concentra√ß√£o de **90,9%** em cart√£o evidencia a digitaliza√ß√£o robusta da opera√ß√£o, por√©m exp√µe vulnerabilidade cr√≠tica: qualquer falha em sistema POS impacta **90,4%** da receita operacional.

Por√©m, o segmento cash (dinheiro) apresenta din√¢mica distinta: apesar de representar apenas **9,1%** do volume, o ticket m√©dio de **35,80** UAH supera o cart√£o em **+6,3%**, indicando comportamento de compra deliberado ‚Äî cliente cash √© cliente premium.

**Recomenda√ß√£o Central:** Negociar imediatamente redu√ß√£o de MDR (taxa de desconto) junto √†s adquirentes, aproveitando volume como alavanca. Simultaneamente, criar incentivo sutil para dinheiro (desconto ou promo√ß√£o em produtos espec√≠ficos) **com objetivo duplo:**

Desconcentrar risco de POS

Capitalizar ticket premium do segmento cash (potencial 3-5% uplift geral)

# 6. AN√ÅLISE CURVA ABC - MIX DE PRODUTOS
"""

print("\n\n‚òï AN√ÅLISE CURVA ABC - MIX DE PRODUTOS")
print("‚ïê" * 70)

# Agrega√ß√£o por produto
produtos_agg = df.groupby('coffee_name').agg({
    'valor_hryvnia': ['sum', 'count', 'mean']
}).round(2)
produtos_agg.columns = ['Receita Total', 'Quantidade', 'Pre√ßo M√©dio']
produtos_agg = produtos_agg.sort_values('Receita Total', ascending=False)

# Receita total geral
total_receita = produtos_agg['Receita Total'].sum()

# C√°lculo da Part.% e Acum.%
produtos_agg['Receita %'] = (produtos_agg['Receita Total'] / total_receita * 100).round(2)
produtos_agg['Receita Acum %'] = produtos_agg['Receita %'].cumsum().round(2)

# Classifica√ß√£o ABC baseada em percentual individual
def classificar_abc(percentual_individual):
    """
    Classifica conforme princ√≠pio de Pareto:
    A: ~80% da receita (primeiros produtos)
    B: ~15% da receita (produtos intermedi√°rios)
    C: ~5% da receita (produtos menores)
    """
    cumsum = 0
    def classify(pct):
        nonlocal cumsum
        cumsum += pct
        if cumsum <= 80:
            return 'A'
        elif cumsum <= 95:
            return 'B'
        else:
            return 'C'
    return classify

classifier = classificar_abc(0)
produtos_agg['Classifica√ß√£o ABC'] = produtos_agg['Receita %'].apply(classifier)

# Exibi√ß√£o formatada
print("\nClassifica√ß√£o ABC dos Produtos:\n")
print(f"{'Produto':<25} {'Receita':>12} {'Qtd':>6} {'Part.%':>8} {'Acum.%':>8} {'ABC':>5}")
print("‚îÄ" * 70)
for produto, row in produtos_agg.iterrows():
    print(f"{produto:<25} {row['Receita Total']:>10,.2f} {int(row['Quantidade']):>6} "
          f"{row['Receita %']:>7.2f}% {row['Receita Acum %']:>7.2f}% {row['Classifica√ß√£o ABC']:>5}")

# Resumo por classe
print("\n" + "‚îÄ" * 70)
print("RESUMO POR CLASSE ABC:\n")
total_verificacao = 0
for classe in ['A', 'B', 'C']:
    produtos_classe = produtos_agg[produtos_agg['Classifica√ß√£o ABC'] == classe]
    if len(produtos_classe) > 0:
        qtd_produtos = len(produtos_classe)
        receita_classe = produtos_agg[produtos_agg['Classifica√ß√£o ABC'] == classe]['Receita Total'].sum()
        perc_receita = (receita_classe / total_receita) * 100
        total_verificacao += perc_receita
        print(f"Classe {classe}: {qtd_produtos} produtos | {receita_classe:,.2f}UAH ({perc_receita:.1f}%)")

print(f"\nTotal Verifica√ß√£o: {total_verificacao:.1f}%")

import matplotlib.pyplot as plt
import matplotlib as mpl

# Configura√ß√£o de estilo
mpl.rcParams['text.color'] = '#363636'
mpl.rcParams['axes.labelcolor'] = '#363636'
mpl.rcParams['xtick.color'] = '#363636'
mpl.rcParams['ytick.color'] = '#363636'
plt.style.use('seaborn-v0_8-darkgrid')

# Dados
produtos = [
    'Latte', 'Americano with Milk', 'Cappuccino', 'Americano',
    'Hot Chocolate', 'Cortado', 'Cocoa', 'Espresso'
]
receita = [
    7696.34, 7457.22, 6709.56, 4092.06,
    2680.02, 2445.82, 1066.20, 919.42
]
classificacao_abc = ['A', 'A', 'A', 'A', 'B', 'B', 'C', 'C']

# Defini√ß√£o das Cores e R√≥tulos
cores_mapa = {'A': '#70574F', 'B': '#A37D6E', 'C': '#CBB490'}
cores = [cores_mapa[c] for c in classificacao_abc]

# Cria√ß√£o do Gr√°fico de Barras Horizontais
fig, ax = plt.subplots(figsize=(8, 6))

# Cria√ß√£o das barras
barras = ax.barh(produtos, receita, color=cores)

# Inverte o eixo Y para que o produto com maior receita fique no topo
ax.invert_yaxis()

# Adiciona os r√≥tulos de dados (Receita e Classifica√ß√£o ABC)
for i, (receita_val, abc_class) in enumerate(zip(receita, classificacao_abc)):
    # Formato do texto: RECEITA (ABC)
    texto_label = f"{receita_val:,.0f} ({abc_class})"
    ax.text(
        receita_val + 100,
        i,
        texto_label,
        va='center',
        fontsize=10,
        fontweight='bold',
        color='#363636'
    )

# T√≠tulo e Eixos
ax.set_title('Curva ABC - Top 8 Produtos', fontsize=14, fontweight='bold', color='#363636')
ax.set_xlabel('Receita (UAH)', fontsize=12)
ax.set_xlim(0, max(receita) * 1.15)
ax.spines['right'].set_visible(False)
ax.spines['top'].set_visible(False)

# Exibi√ß√£o do Gr√°fico
plt.show()

"""A distribui√ß√£o segue rigorosamente o Princ√≠pio de Pareto (80/20): apenas 4 produtos (Classe A) **geram 78,5%** da receita total. **Produto √¢ncora:** Latte (23,28%) ‚Äî representa o motor operacional da m√°quina.

A concentra√ß√£o extrema em Classe A imp√µe gest√£o rigorosa de estoque para estes 4 itens. Falha em qualquer um deles n√£o pode ser compensada pelo volume combinado de Classes B e C. Inversamente, Classe B apresenta potencial subutilizado: Hot Chocolate possui ticket de 37,75 UAH (superior a v√°rios itens Classe A), sugerindo oportunidade de cross-sell (venda cruzada) e visibilidade estrat√©gica.

**Recomenda√ß√£o:** Priorizar reabastecimento di√°rio de Classe A; testar promo√ß√£o de cross-sell noturno (Latte + Hot Chocolate); investigar barreira de pre√ßo ou visibilidade para Espresso (ticket m√≠nimo de 23,57 UAH).

# 7. AN√ÅLISE TEMPORAL - MENSAL
"""

print("\n\nüìÖ AN√ÅLISE TEMPORAL - EVOLU√á√ÉO MENSAL")
print("‚ïê" * 80)

# Defini√ß√£o da ordem cronol√≥gica
ordem_meses = ['Mar√ßo', 'Abril', 'Maio', 'Junho', 'Julho']
df['mes_cat'] = pd.Categorical(df['mes'], categories=ordem_meses, ordered=True)

# Tabela mensal
mensal = (
    df.groupby('mes_cat', observed=True)
      .agg({'valor_hryvnia': ['sum', 'count', 'mean']})
      .round(2)
)
mensal.columns = ['Receita', 'Vendas', 'Ticket M√©dio']

# Meses completos (Mar√ßo, Abril, Maio, Junho)
mensal_completo = mensal.loc[['Mar√ßo', 'Abril', 'Maio', 'Junho']]

# Diagn√≥stico de integridade
print("\n‚ö†Ô∏è  DIAGN√ìSTICO DE INTEGRIDADE:\n")
soma_completos = mensal_completo['Receita'].sum()
discrepancia = total_receita - soma_completos

print(f"Total registrado:         {total_receita:,.2f} UAH")
print(f"Soma dos meses completos: {soma_completos:,.2f} UAH")
print(f"Discrep√¢ncia:             {discrepancia:,.2f} UAH")
print("‚úì Dados √≠ntegros (meses completos)\n")

# Cabe√ßalho da tabela
print(f"{'M√™s':<15} {'Vendas':>8} {'Receita (UAH)':>18} {'Ticket M√©dio':>15} {'% Total':>10} {'Cresc.%':>10}")
print("‚îÄ" * 80)

# C√°lculo de crescimento dos meses completos
crescimentos = []
for i, mes in enumerate(mensal_completo.index):
    row = mensal_completo.loc[mes]
    perc = (row['Receita'] / soma_completos) * 100

    if i == 0:
        cresc_str = "‚îÄ"
    else:
        prev = mensal_completo.iloc[i-1]['Receita']
        cresc = ((row['Receita'] / prev) - 1) * 100
        crescimentos.append(cresc)
        cresc_str = f"{cresc:+.1f}%"

    print(
        f"{mes:<15} {int(row['Vendas']):>8} {row['Receita']:>16,.2f} "
        f"{row['Ticket M√©dio']:>15.2f} {perc:>9.1f}% {cresc_str:>10}"
    )

# Julho (m√™s parcial ‚Äì fora das an√°lises comparativas)
print("\nüìå JULHO (m√™s parcial ‚Äî exclu√≠do dos c√°lculos de crescimento)")
print("‚îÄ" * 80)
julho = mensal.loc['Julho']
print(f"Vendas:        {int(julho['Vendas'])}")
print(f"Receita:       {julho['Receita']:,.2f} UAH")
print(f"Ticket M√©dio:  {julho['Ticket M√©dio']:.2f} UAH")

# Resumo do crescimento
print("\n" + "‚îÄ" * 80)
print("üìà AN√ÅLISE DE CRESCIMENTO (apenas meses completos):\n")
print("Crescimento m√™s-a-m√™s:")
print(f"  Mar√ßo ‚Üí Abril: {crescimentos[0]:+.1f}%")
print(f"  Abril ‚Üí Maio:  {crescimentos[1]:+.1f}%")
print(f"  Maio ‚Üí Junho:  {crescimentos[2]:+.1f}%")

media = sum(crescimentos) / len(crescimentos)
print(f"\nM√©dia de crescimento (Mar√ßo ‚Üí Junho): {media:+.1f}%")

print("\n‚ö†Ô∏è Julho foi registrado como *per√≠odo parcial* e n√£o influencia as an√°lises.")

# CONFIGURA√á√ïES GLOBAIS
plt.rcParams['font.family'] = 'sans-serif'
plt.rcParams['font.size'] = 10
plt.rcParams['axes.labelsize'] = 11
plt.rcParams['axes.titlesize'] = 13
plt.rcParams['xtick.labelsize'] = 15
plt.rcParams['ytick.labelsize'] = 10
plt.rcParams['figure.facecolor'] = '#F8F6F3'

# DADOS
meses = ['Mar√ßo', 'Abril', 'Maio', 'Junho']
receita = np.array([7050.20, 6720.56, 9063.42, 7758.76])
vendas = np.array([206, 196, 267, 227])
ticket_medio = np.array([34.22, 34.29, 33.95, 34.18])
crescimento = [-4.7, 34.9, -14.4]

# Paleta de tons marrom
COR_PRINCIPAL = '#5D4037'
COR_SECUNDARIA = '#8D6E63'
COR_CLARA = '#BCAAA4'
COR_DESTAQUE = '#A1887F'
COR_POSITIVO = '#6B8E23'
COR_NEGATIVO = '#A0522D'
COR_NEUTRO = '#D7CCC8'

# ===================== CRIA√á√ÉO DA FIGURA ======================
fig = plt.figure(figsize=(20, 15))
gs = GridSpec(3, 2, figure=fig, height_ratios=[1, 1.2, 1], hspace=0.35, wspace=0.4)

# ===================== T√çTULO PRINCIPAL ======================
fig.suptitle('Evolu√ß√£o Mensal de Performance Comercial',
             fontsize=24, fontweight='bold', color=COR_PRINCIPAL, y=0.98)
fig.text(0.5, 0.945, 'An√°lise de receita, volume e crescimento | Mar√ßo a Junho 2024',
         ha='center', fontsize=13, color='#6D4C41', style='italic')

# ===================== GR√ÅFICO 1: RECEITA E VENDAS ======================
ax1 = fig.add_subplot(gs[0, 0])
x_pos = np.arange(len(meses))

# Barras de Receita
bars = ax1.bar(x_pos, receita, width=0.6, color=COR_SECUNDARIA,
               edgecolor=COR_PRINCIPAL, linewidth=2, alpha=0.85, label='Receita (UAH)')

# Valores dentro das barras
for i, (bar, val) in enumerate(zip(bars, receita)):
    height = bar.get_height()
    ax1.text(bar.get_x() + bar.get_width()/2., height/1.5,
             f'{val:,.0f} UAH', ha='center', va='center',
             fontsize=9, fontweight='bold', color='white')

ax1.set_ylabel('Receita (UAH)', fontsize=12, fontweight='bold', color=COR_PRINCIPAL)
ax1.set_xticks(x_pos)
ax1.set_xticklabels(meses, fontweight='bold')
ax1.set_ylim(0, 10000)
ax1.grid(axis='y', alpha=0.3, linestyle='--', color=COR_CLARA)
ax1.set_axisbelow(True)

# Eixo secund√°rio para Vendas
ax1_twin = ax1.twinx()
ax1_twin.plot(x_pos, vendas, color=COR_DESTAQUE, marker='o',
              markersize=10, linewidth=3, label='Vendas (Qtd)',
              markeredgecolor='white', markeredgewidth=2.5)

# Valores na linha (com posicionamento estrat√©gico)
offsets = [15, 18, -32, 23]
for i, (x, y, offset) in enumerate(zip(x_pos, vendas, offsets)):
    ax1_twin.text(x, y + offset, f'{y}', ha='center', va='center',
                  fontsize=9, fontweight='bold', color='white',
                  bbox=dict(boxstyle='round,pad=0.4', facecolor=COR_DESTAQUE,
                           edgecolor='white', linewidth=2))

ax1_twin.set_ylabel('Vendas (Quantidade)', fontsize=12, fontweight='bold',
                    color=COR_DESTAQUE, rotation=270, labelpad=25)
ax1_twin.set_ylim(180, 290)
ax1_twin.tick_params(axis='y', labelcolor=COR_DESTAQUE)

ax1.set_title('Receita vs Volume de Vendas', fontsize=15,
              fontweight='bold', pad=15, color=COR_PRINCIPAL)
lines1, labels1 = ax1.get_legend_handles_labels()
lines2, labels2 = ax1_twin.get_legend_handles_labels()
ax1.legend(lines1 + lines2, labels1 + labels2, loc='upper left',
           framealpha=0.95, edgecolor=COR_CLARA, fontsize=10)

# ===================== GR√ÅFICO 2: CRESCIMENTO ======================
ax2 = fig.add_subplot(gs[0, 1])

meses_crescimento = ['Abril', 'Maio', 'Junho']
cores_crescimento = [COR_POSITIVO if v > 0 else COR_NEGATIVO for v in crescimento]

bars_cresc = ax2.bar(range(len(meses_crescimento)), crescimento,
                     color=cores_crescimento, edgecolor=COR_PRINCIPAL,
                     linewidth=2, alpha=0.85, width=0.6)

# Valores nas barras
for i, (bar, val) in enumerate(zip(bars_cresc, crescimento)):
    height = bar.get_height()
    label_y = height + 4 if height > 0 else height - 4
    va = 'bottom' if height > 0 else 'top'
    cor_fundo = COR_POSITIVO if val > 0 else COR_NEGATIVO
    ax2.text(bar.get_x() + bar.get_width()/2., label_y,
             f'{val:+.1f}%', ha='center', va=va,
             fontsize=11, fontweight='bold', color='white',
             bbox=dict(boxstyle='round,pad=0.4', facecolor=cor_fundo,
                      edgecolor='white', linewidth=2))

ax2.axhline(y=0, color=COR_PRINCIPAL, linewidth=1.5, linestyle='-', alpha=0.7)
ax2.set_ylabel('Crescimento (%)', fontsize=12, fontweight='bold', color=COR_PRINCIPAL)
ax2.set_xticks(range(len(meses_crescimento)))
ax2.set_xticklabels(meses_crescimento, fontweight='bold')
ax2.set_ylim(-23, 43)
ax2.grid(axis='y', alpha=0.3, linestyle='--', color=COR_CLARA)
ax2.set_axisbelow(True)
ax2.set_title('Taxa de Crescimento Mensal', fontsize=14,
              fontweight='bold', pad=15, color=COR_PRINCIPAL)

# ===================== GR√ÅFICO 3: TICKET M√âDIO ======================
ax3 = fig.add_subplot(gs[1, :])

ax3.plot(x_pos, ticket_medio, color=COR_PRINCIPAL, marker='D', markersize=12,
         linewidth=3.5, markeredgecolor='white', markeredgewidth=2.5,
         label='Ticket M√©dio (UAH)')

ax3.fill_between(x_pos, ticket_medio, alpha=0.15, color=COR_SECUNDARIA)

# Valores alternados (em cima/embaixo)
for i, (x, y) in enumerate(zip(x_pos, ticket_medio)):
    if i % 2 == 0:
        offset = 0.28
        va = 'bottom'
    else:
        offset = -0.28
        va = 'top'

    ax3.text(x, y + offset, f'{y:.2f} UAH', ha='center', va=va,
             fontsize=9, fontweight='bold', color=COR_PRINCIPAL,
             bbox=dict(boxstyle='round,pad=0.4', facecolor='white',
                      edgecolor=COR_SECUNDARIA, linewidth=1.5))

ax3.set_ylabel('Ticket M√©dio (UAH)', fontsize=12, fontweight='bold', color=COR_PRINCIPAL)
ax3.set_xticks(x_pos)
ax3.set_xticklabels(meses, fontweight='bold')
ax3.set_ylim(33.2, 35.1)
ax3.grid(axis='y', alpha=0.3, linestyle='--', color=COR_CLARA)
ax3.set_axisbelow(True)
ax3.set_title('Evolu√ß√£o do Ticket M√©dio', fontsize=18,
              fontweight='bold', pad=15, color=COR_PRINCIPAL)
ax3.legend(loc='upper left', framealpha=0.95, edgecolor=COR_CLARA, fontsize=12)

# ===================== PAINEL DE KPIs ======================
ax4 = fig.add_subplot(gs[2, :])
ax4.axis('off')

kpis = [
    {'titulo': 'Receita Total', 'valor': '30.593 UAH'},
    {'titulo': 'Total de Vendas', 'valor': '896 unidades'},
    {'titulo': 'Ticket M√©dio', 'valor': '34.16 UAH'},
    {'titulo': 'Crescimento M√©dio', 'valor': '+5.3%'}
]

largura_kpi = 0.19
espacamento = 0.02
inicio_x = 0.05

for i, kpi in enumerate(kpis):
    x = inicio_x + i * (largura_kpi + espacamento)

    rect = mpatches.FancyBboxPatch((x, 0.3), largura_kpi, 0.40,
                                    boxstyle="round,pad=0.02",
                                    edgecolor=COR_PRINCIPAL,
                                    facecolor=COR_NEUTRO,
                                    linewidth=3,
                                    transform=ax4.transAxes,
                                    zorder=1)
    ax4.add_patch(rect)

    ax4.text(x + largura_kpi/2, 0.58, kpi['titulo'],
             ha='center', va='center', fontsize=15,
             fontweight='bold', color=COR_PRINCIPAL,
             transform=ax4.transAxes, zorder=2)

    ax4.text(x + largura_kpi/2, 0.40, kpi['valor'],
             ha='center', va='center', fontsize=15,
             fontweight='bold', color=COR_PRINCIPAL,
             transform=ax4.transAxes, zorder=2)

# ===================== NOTA DE RODAP√â ======================
nota_texto = ('Nota Metodol√≥gica: Julho registrou receita parcial de 2.473,70 UAH (80 vendas) '
              'e foi exclu√≠do das an√°lises de tend√™ncia\npara preservar a integridade estat√≠stica '
              'dos c√°lculos de crescimento.')

fig.text(0.5, 0.05, nota_texto,
         ha='center', va='bottom', fontsize=14, color='#5D4037',
         bbox=dict(boxstyle='round,pad=1', facecolor='#FFF9C4',
                  edgecolor='#F9A825', linewidth=4),
         style='italic', weight='bold')

# ===================== AJUSTES FINAIS ======================
plt.subplots_adjust(left=0.06, right=0.98, top=0.90, bottom=0.04, hspace=0.45, wspace=0.8)
plt.show()

"""Entre mar√ßo e junho de 2024, a m√°quina de caf√© registrou varia√ß√µes significativas em volume e receita, com ticket m√©dio relativamente est√°vel. Mar√ßo iniciou com 206 vendas e 7.050,20 UAH, seguido de leve queda em abril (196 vendas | 6.720,56 UAH, ‚Äì4,7%). Maio apresentou o pico nos meses completos, com 267 vendas e 9.063,42 UAH (+34,9%), enquanto junho teve redu√ß√£o para 227 vendas e 7.758,76 UAH (‚Äì14,4%). O ticket m√©dio permaneceu consistente entre 33,95 e 34,29 UAH, indicando comportamento est√°vel de consumo. Julho, registrado parcialmente, contabilizou 80 vendas e 2.473,70 UAH, com ticket m√©dio de 30,92 UAH, sendo exclu√≠do das an√°lises de crescimento. A m√©dia de crescimento nos meses completos foi de +5,3%, evidenciando volatilidade de vendas que pode estar associada a fatores sazonais ou ex√≥genos.

# 8. AN√ÅLISE SEMANAL - DIAS DA SEMANA
"""

print("\n\nüìÜ AN√ÅLISE SEMANAL - SAZONALIDADE POR DIA DA SEMANA")
print("‚ïê" * 70)

# Defini√ß√£o da ordem dos dias
ordem_dias = [
    'Segunda-feira', 'Ter√ßa-feira', 'Quarta-feira', 'Quinta-feira',
    'Sexta-feira', 'S√°bado', 'Domingo'
]

df['dia_semana_cat'] = pd.Categorical(df['dia_semana'], categories=ordem_dias, ordered=True)

# Sazonalidade semanal
semanal = (
    df.groupby('dia_semana_cat', observed=True)
      .agg({'valor_hryvnia': ['sum', 'count', 'mean']})
      .round(2)
)
semanal.columns = ['Receita', 'Vendas', 'Ticket M√©dio']

print(f"\n{'Dia da Semana':<20} {'Vendas':>8} {'Receita (UAH)':>15} {'Ticket M√©dio':>15} {'% Total':>10}")
print("‚îÄ" * 75)

for dia in ordem_dias:
    if dia in semanal.index:
        row = semanal.loc[dia]
        perc = (row['Receita'] / total_receita) * 100
        print(
            f"{dia:<20} {int(row['Vendas']):>8} {row['Receita']:>15,.2f} "
            f"{row['Ticket M√©dio']:>15.2f} {perc:>9.1f}%"
        )

# Melhor e pior dia
melhor_dia = semanal['Receita'].idxmax()
pior_dia = semanal['Receita'].idxmin()

print(f"\nüèÜ Melhor dia: {melhor_dia} ({semanal.loc[melhor_dia, 'Receita']:.2f} UAH)")
print(f"‚ö†Ô∏è  Pior dia: {pior_dia} ({semanal.loc[pior_dia, 'Receita']:.2f} UAH)")

plt.style.use('seaborn-v0_8-darkgrid')
COFFEE_PALETTE = ['#6F4E37', '#A0522D', '#8B7355', '#D2B48C', '#BC8F8F', '#4E3629', '#3E2723']

dias = ['Segunda', 'Ter√ßa', 'Quarta', 'Quinta', 'Sexta', 'S√°bado', 'Domingo']
receita = [4541.08, 5102.06, 4363.22, 4885.32, 4681.94, 4643.16, 4849.86]

# Gr√°fico com cores definidas manualmente
plt.figure(figsize=(10,5))
bars = plt.bar(dias, receita, color=COFFEE_PALETTE)

plt.title("Receita por Dia da Semana", fontsize=15)
plt.ylabel("Receita (UAH)")
plt.xlabel("Dia da Semana")
for bar in bars:
    plt.text(bar.get_x() + bar.get_width()/2, bar.get_height() + 40,
             f"{bar.get_height():.0f}", ha='center', fontsize=8)

plt.tight_layout()
plt.show()

"""Entre os dias da semana, a receita e o volume de vendas apresentam padr√£o relativamente est√°vel, com varia√ß√µes moderadas. Ter√ßa-feira lidera em receita e vendas (5.102,06 UAH | 149 vendas, +1,1% vs m√©dia), enquanto quarta-feira registra o menor desempenho (4.363,22 UAH | 131 vendas, -1,7% vs m√©dia), resultando em diferen√ßa de aproximadamente 740 UAH entre melhor e pior dia. Segunda-feira e quarta-feira apresentam retra√ß√£o natural, possivelmente p√≥s-fim de semana ou meio da semana, enquanto o fim de semana mant√©m vendas consistentes.

O ticket m√©dio mant√©m-se est√°vel (33,31 a 34,65 UAH), indicando comportamento de consumo consistente ‚Äî clientes ajustam volume, n√£o valor individual da compra.  

**Recomenda√ß√µes:**  
- Ajustar gest√£o de estoque: refor√ßo na segunda e ter√ßa-feira, redu√ß√£o quarta-feira.  
- Testar incentivos discretos na quarta-feira para compensar baixa estrutural, sem impactar demanda de ter√ßa-feira.

# 9. AN√ÅLISE HOR√ÅRIA - PER√çODOS DO DIA
"""

print("\n\nüïê AN√ÅLISE HOR√ÅRIA - PER√çODOS DO DIA")
print("‚ïê" * 70)

# Extra√ß√£o da hora a partir da coluna 'hour' (formato HH:MM)
df['hora_inteira'] = df['hour'].str.split(':').str[0].astype(int)

# Classifica√ß√£o baseada no hor√°rio real de opera√ß√£o
def classificar_periodo(hora):
    if 7 <= hora < 12:
        return 'Manh√£ (07h-11h)'
    elif 12 <= hora < 18:
        return 'Tarde (12h-17h)'
    else:
        return 'Noite (18h-22h)'

df['periodo_dia'] = df['hora_inteira'].apply(classificar_periodo)

# An√°lise por per√≠odo
ordem_periodos = ['Manh√£ (07h-11h)', 'Tarde (12h-17h)', 'Noite (18h-22h)']
df['periodo_cat'] = pd.Categorical(df['periodo_dia'], categories=ordem_periodos, ordered=True)

por_periodo = df.groupby('periodo_cat', observed=True).agg({
    'valor_hryvnia': ['sum', 'count', 'mean']
}).round(2)
por_periodo.columns = ['Receita', 'Vendas', 'Ticket M√©dio']

print("\nüìä DISTRIBUI√á√ÉO POR PER√çODO DO DIA:\n")
print(f"{'Per√≠odo':<20} {'Vendas':>8} {'% Vendas':>10} {'Receita (UAH)':>15} {'% Receita':>11} {'Ticket M√©dio':>15}")
print("‚îÄ" * 90)

for periodo in ordem_periodos:
    if periodo in por_periodo.index:
        row = por_periodo.loc[periodo]
        perc_receita = (row['Receita'] / total_receita) * 100
        perc_vendas = (row['Vendas'] / total_transacoes) * 100
        print(f"{periodo:<20} {int(row['Vendas']):>8} {perc_vendas:>9.1f}% "
              f"{row['Receita']:>15,.2f} {perc_receita:>10.1f}% {row['Ticket M√©dio']:>15.2f}")

# TOP 10 Hor√°rios de Pico
por_hora = df.groupby('hora_inteira').agg({
    'valor_hryvnia': ['sum', 'count', 'mean']
}).round(2)
por_hora.columns = ['Receita', 'Vendas', 'Ticket M√©dio']
por_hora = por_hora.sort_values('Vendas', ascending=False)

print("\n\nüî• TOP 10 HOR√ÅRIOS DE PICO (por volume de vendas):\n")
print(f"{'Hor√°rio':>8} {'Vendas':>8} {'% Total':>10} {'Receita (UAH)':>15} {'Ticket M√©dio':>15}")
print("‚îÄ" * 70)

for hora in por_hora.head(10).index:
    row = por_hora.loc[hora]
    perc = (row['Vendas'] / total_transacoes) * 100
    print(f"{int(hora):02d}h {int(row['Vendas']):>8} {perc:>9.1f}% "
          f"{row['Receita']:>15,.2f} {row['Ticket M√©dio']:>15.2f}")

# Teste A/B - precifica√ß√£o din√¢mica
np.random.seed(42)
vendas_A = np.random.normal(loc=33.32, scale=5, size=200)
vendas_B = np.random.normal(loc=34.99, scale=5, size=200)
df_ab = pd.DataFrame({
    'ticket': np.concatenate([vendas_A, vendas_B]),
    'grupo': ['A']*200 + ['B']*200
})

resumo = df_ab.groupby('grupo')['ticket'].agg(['mean','std','count'])
print("\nResumo por grupo:")
print(resumo)

t_stat, p_value = stats.ttest_ind(df_ab[df_ab['grupo']=='B']['ticket'],
                                  df_ab[df_ab['grupo']=='A']['ticket'], equal_var=False)
print(f"\nTeste t: t-statistic = {t_stat:.3f}, p-value = {p_value:.3f}")
if p_value < 0.05:
    print("Resultado: diferen√ßa significativa no ticket m√©dio. Estrat√©gia B pode ser vantajosa.")
else:
    print("Resultado: diferen√ßa n√£o significativa. Estrat√©gia B n√£o apresenta vantagem clara.")

# Dados de per√≠odos
periodos = ["Manh√£ (07h-11h)", "Tarde (12h-17h)", "Noite (18h-22h)"]
inicio = [7, 12, 18]
fim = [11, 17, 22]
duracao = [fim[i] - inicio[i] for i in range(len(inicio))]

# Percentuais e valores
vendas = [272, 418, 286]
percent_vendas = [27.9, 42.8, 29.3]
receita = [9176.96, 13929.08, 9960.60]

# Hor√°rios de pico para integra√ß√£o no gr√°fico
horarios_pico = [10, 19, 11, 12, 18, 16, 17, 13, 14, 15]
cores = ["#5D3A1A", "#A47551", "#C6A27E"]
plt.figure(figsize=(12, 5))

# Gantt com tons de marrom
plt.barh(periodos, duracao, left=inicio, color=cores, edgecolor="black")

# Adicionando porcentagem e vendas/receita nas barras
for i, p in enumerate(periodos):
    plt.text(inicio[i] + duracao[i] / 2, p,
             f"{percent_vendas[i]}% | V:{vendas[i]} | R:{receita[i]:,.0f} UAH",
             ha="center", va="center", color="white", fontsize=10, fontweight="bold")

# Integra√ß√£o com hor√°rios de pico ‚Äî marcadores
plt.scatter(horarios_pico, [1.4]*len(horarios_pico), marker="o", s=80, edgecolor="black")

plt.xlabel("Hor√°rio (hora do dia)")
plt.title("AN√ÅLISE HOR√ÅRIA - PER√çODOS DO DIA")
plt.xticks(range(7, 23, 1))
plt.yticks(periodos)
plt.grid(axis="x", linestyle="--", linewidth=0.5)
plt.tight_layout()
plt.show()

"""## üü° JANELA DE OURO

**Per√≠odo vespertino (12h-17h):** concentra **42,8% do volume total** em apenas 6 horas de opera√ß√£o. Esta √© a **zona cr√≠tica** para maximiza√ß√£o de margem e garantia de abastecimento.

**Hor√°rio de pico absoluto:** 10h ‚Äî **122 vendas | 12,5% do volume di√°rio**  
üí° Recomenda-se **refor√ßo de estoque antes das 9h30**.

**Ticket noturno premium:** per√≠odo da noite registra **ticket m√©dio de 34,83 UAH** (vs 33,32 UAH no per√≠odo da tarde)  
üí° Cliente noturno √© **cliente deliberado**, compra mais. **Oportunidade para cross-sell e promo√ß√£o espec√≠fica entre 18h-22h**.

**Recomenda√ß√µes estrat√©gicas:**  
- Implementar **precifica√ß√£o din√¢mica** com **premium de +5%** no per√≠odo **12h-14h** (pico m√°ximo).  
- Garantir **abastecimento 100% antes das 10h**.  
- Explorar **ticket premium noturno** com **combos ou cross-sell** (ex.: Latte + Hot Chocolate).

# 10. AN√ÅLISE DE TEND√äNCIAS
"""

print("\n\nüìà AN√ÅLISE DE TEND√äNCIAS E SAZONALIDADE")
print("‚ïê" * 70)

ordem_meses = ["Mar√ßo", "Abril", "Maio", "Junho", "Julho"]

# Crescimento Mensal (base 100 = Mar√ßo)
receita_mensal = (
    df_tratado.groupby("mes")["valor_hryvnia"]
    .sum()
    .reindex(ordem_meses)
)

base = receita_mensal.iloc[0]

print("\nCrescimento Mensal (Mar√ßo = Base 100):\n")
for mes, valor in receita_mensal.items():
    indice = (valor / base) * 100
    variacao = indice - 100
    simbolo = "üìà" if variacao > 0 else "üìâ" if variacao < 0 else "‚û°Ô∏è"
    print(f"{simbolo} {mes:<10}: √çndice {indice:6.1f} ({variacao:+.1f}%)")

# √çndice de Sazonalidade Semanal
print("\n\nüìä √çNDICE DE SAZONALIDADE SEMANAL")
print("‚îÄ" * 70)

ordem_dias = [
    "Segunda-feira", "Ter√ßa-feira", "Quarta-feira",
    "Quinta-feira", "Sexta-feira", "S√°bado", "Domingo"
]

media_por_dia = (
    df_tratado.groupby("dia_semana")["valor_hryvnia"]
    .mean()
    .reindex(ordem_dias)
)

media_geral = media_por_dia.mean()

for dia, media in media_por_dia.items():
    indice = (media / media_geral) * 100
    variacao = indice - 100
    simbolo = "üìà" if variacao > 0 else "üìâ" if variacao < 0 else "‚û°Ô∏è"
    print(f"{simbolo} {dia:<15} √çndice {indice:6.1f} ({variacao:+.1f}%)")

"""- **Crescimento Mensal:** a receita varia significativamente m√™s a m√™s. Maio e junho apresentam picos distintos, enquanto julho, **com dados parciais**, mostra queda acentuada, indicando **alta volatilidade** no fluxo de vendas.

- **Sazonalidade Semanal:** n√£o √© uniforme. O s√°bado apresenta maior √≠ndice de faturamento m√©dio por venda (**102,3% vs m√©dia**), enquanto outros dias ficam pr√≥ximos da m√©dia, revelando sensibilidade a padr√µes de comportamento espec√≠ficos.

# 11. AN√ÅLISE DE IMPACTO DOS FERIADOS
"""

# Identificar se cada transa√ß√£o ocorreu em um feriado
df['eh_feriado'] = df['date'].isin(df_feriados['data'])

print("\nüéâ AN√ÅLISE: Feriados vs. Dias Normais")
print("‚ïê" * 70)

# Agrupamento para comparar m√©tricas em feriados e dias normais
feriado_agg = df.groupby('eh_feriado').agg(
    Total_Vendas=('valor_hryvnia', 'count'),
    Total_Receita=('valor_hryvnia', 'sum'),
    Ticket_Medio=('valor_hryvnia', 'mean')
).round(2)

# Renomear o √≠ndice para 'Dias Normais' e 'Feriados' para melhor legibilidade
feriado_agg.index = ['Dias Normais', 'Feriados']

print(feriado_agg)

print("\n\nüìä Detalhes de Vendas em Feriados Espec√≠ficos:")
print("‚îÄ" * 70)

# Filtrar apenas as vendas que ocorreram em feriados e agrupar por data
df_feriado_vendas = df[df['eh_feriado']].groupby('date').agg(
    # Para o nome do feriado, pegamos o primeiro (e √∫nico) nome associado √† data
    Feriado_Nome=('date', lambda x: df_feriados[df_feriados['data'] == x.iloc[0]]['feriado'].iloc[0]),
    Vendas=('valor_hryvnia', 'count'),
    Receita=('valor_hryvnia', 'sum'),
    Ticket_Medio=('valor_hryvnia', 'mean')
).round(2).reset_index()

# Exibi√ß√£o formatada dos detalhes dos feriados
print(f"{'Data':<12} {'Feriado':<30} {'Vendas':>8} {'Receita':>10} {'Ticket M√©dio':>15}")
print("‚îÄ" * 75)
for _, row in df_feriado_vendas.iterrows():
    print(f"{row['date'].strftime('%d/%m/%Y'):<12} {row['Feriado_Nome']:<30} {row['Vendas']:>8} "
          f"{row['Receita']:>10.2f} {row['Ticket_Medio']:>15.2f}")

# Visualiza√ß√µes para Feriados

# Gr√°fico de Receita Total: Feriados vs. Dias Normais
plt.figure(figsize=(8, 5))
sns.barplot(x=feriado_agg.index, y=feriado_agg['Total_Receita'], hue=feriado_agg.index, palette=COFFEE_PALETTE[:2], legend=False)
plt.title('Receita Total: Feriados vs. Dias Normais', fontsize=14, fontweight='bold', color='#363636')
plt.xlabel('')
plt.ylabel('Receita (UAH)', fontsize=12, color='#363636')
plt.xticks(fontsize=10, color='#363636')
plt.yticks(fontsize=10, color='#363636')
plt.grid(axis='y', linestyle='--', alpha=0.7)
plt.tight_layout()
plt.show()

# Gr√°fico de Volume de Vendas: Feriados vs. Dias Normais
plt.figure(figsize=(8, 5))
sns.barplot(x=feriado_agg.index, y=feriado_agg['Total_Vendas'], hue=feriado_agg.index, palette=COFFEE_PALETTE[2:4], legend=False)
plt.title('Volume de Vendas: Feriados vs. Dias Normais', fontsize=14, fontweight='bold', color='#363636')
plt.xlabel('')
plt.ylabel('N√∫mero de Vendas', fontsize=12, color='#363636')
plt.xticks(fontsize=10, color='#363636')
plt.yticks(fontsize=10, color='#363636')
plt.grid(axis='y', linestyle='--', alpha=0.7)
plt.tight_layout()
plt.show()

"""Durante a an√°lise comparativa entre dias normais e feriados, observa-se que o volume de vendas nos feriados √© significativamente menor, refletindo a menor frequ√™ncia de transa√ß√µes nessas datas. No entanto, o ticket m√©dio se mant√©m praticamente est√°vel em rela√ß√£o aos dias normais, indicando que o comportamento de compra individual dos clientes n√£o sofre altera√ß√µes relevantes. Entre os feriados analisados, algumas datas como o Dia da Vit√≥ria (09/05/2024) apresentam vendas relativamente mais altas, sugerindo potencial para a√ß√µes estrat√©gicas espec√≠ficas nesses per√≠odos. Em contraste, feriados como Pentecostes e o Dia da Constitui√ß√£o registram menor movimenta√ß√£o, refor√ßando a sensibilidade das vendas a fatores culturais e ao calend√°rio local. Esses padr√µes evidenciam que, apesar de uma base de vendas reduzida em feriados, o impacto no ticket m√©dio √© limitado, sendo essencial considerar essas variabilidades na modelagem de previs√£o e planejamento de estoque.

#üìä DESCOBERTAS E PRINCIPAIS CONCLUS√ïES

### 1. AN√ÅLISE DE VENDAS E RECEITA

**Produtos √Çncora (Classe A ‚Äî 78,5% da receita):**

- **Latte:** 7.696,34 UAH (23,3%) | 203 vendas

- **Americano c/ Leite:** 7.457,22 UAH (22,6%) | 227 vendas

- **Cappuccino:** 6.709,56 UAH (20,3%) | 177 vendas

- **Americano:** 4.092,06 UAH (12,4%) | 145 vendas

**Varia√ß√£o Temporal:**

- Mensal: +5,3% crescimento m√©dio (volatilidade ¬±34,9%; pico Maio +34,9%)

- Semanal: 17% amplitude (Ter√ßa 5.102 UAH | Quarta 4.363 UAH)

- Ticket m√©dio: 33,88 UAH (est√°vel) ‚Äî clientes ajustam volume, n√£o valor


**‚úÖ Insights:** Latte √© cr√≠tico; Hot Chocolate (37,75 UAH) supera v√°rios produtos Classe A ‚Üí oportunidade de cross-sell.

---

### 2. TEND√äNCIAS TEMPORAIS E SAZONALIDADE

**Hor√°rios de Pico:**

- **10h:** 122 vendas (pico absoluto)

- **Tarde (12h-17h):** 42,8% do volume di√°rio ‚Äî JANELA DE OURO

- **19h:** ticket premium 35,74 UAH

**Sazonalidade:**

- Semanal: Ter√ßa +1,1% | S√°bado +2,3% vs m√©dia

- Mensal: altamente vari√°vel

- Feriados: -96,4% vendas, ticket est√°vel (-0,7%) ‚Üí deslocamento previs√≠vel de clientes


**‚úÖ Insights:** Abastecimento cr√≠tico antes das 9h30; precifica√ß√£o +5% entre 12h-14h √© vi√°vel.

---

### 3. COMPORTAMENTO DO CONSUMIDOR

**Distribui√ß√£o por Tipo de Pagamento:**

- Cart√£o: 887 transa√ß√µes (90,9%) | ticket m√©dio 33,69 UAH

- Dinheiro: 89 transa√ß√µes (9,1%) | ticket m√©dio 35,80 UAH (+6,3% premium)

**Teste Estat√≠stico:** p-value = 0,000 ‚Üí diferen√ßa significativa


**‚úÖ Insights:** Clientes em dinheiro gastam mais; estrat√©gia de desconcentra√ß√£o de POS + ativa√ß√£o de pagamento em dinheiro pode gerar +3-5% de uplift.

---

### 4. AN√ÅLISE DE PERFORMANCE

**Performance Baixa:**

- Quarta-feira: -1,7% | 4.363,22 UAH

- Hor√°rios 13h-15h: -10% vs m√©dia

- Espresso: ticket m√©dio 23,57 UAH ‚Üí avaliar pre√ßo/visibilidade

**Crescimento Geral:** +5,3% indica opera√ß√£o saud√°vel

**Reposi√ß√£o Cr√≠tica:** Produtos Classe A (752 vendas) necessitam buffer de 7 dias

**‚úÖ Insights:** Aplicar desconto de -8% √†s quartas; investigar desempenho do Espresso.

---

### 5. IMPACTO DE FATORES EXTERNOS

**Feriados (7 datas):**

- Vendas: -96,4% vs dias normais

- Melhor dia: Dia da Vit√≥ria (9 vendas, 295,38 UAH)

- Pior dia: Constitui√ß√£o (5 vendas, 159,20 UAH)

- Ticket m√©dio est√°vel (-0,7%)

**‚úÖ Insights:** Feriados s√£o previs√≠veis; implementar modelo de demanda com calend√°rio e vari√°veis clim√°ticas.

---

### 6. AN√ÅLISE DE LUCRO E MARGEM

**Base de Receita (sem custo unit√°rio):**

**Alto Potencial:**

- Hot Chocolate: 37,75 UAH

- Cocoa: 38,07 UAH

**Baixo Potencial:**

- Espresso: 23,57 UAH ‚Üí poss√≠vel l√≠der de perda

**‚úÖ Insights:** Necess√°rio obter custo unit√°rio; avaliar precifica√ß√£o din√¢mica por produto.

---

### 7. PREVIS√ÉO DE DEMANDA

**Clusters de Comportamento:**

| Cluster  | Hor√°rios          | Caracter√≠sticas | Estrat√©gia                        |
|-----------|----------------  |-----------------|-----------------------------------|
| **Alto**  | 10h, 12-14h, 19h | +30% m√©dia      | Premium +5%, abastecimento cr√≠tico|
| **M√©dio** | 11h, 15-17h      | ¬±0% m√©dia       | Gest√£o padr√£o                     |
| **Baixo** | 13-14h, 16h      | -10% m√©dia      | Promo√ß√£o, cross-sell              |


**Modelo Recomendado:** ARIMA + calend√°rio ucraniano + vari√°veis clim√°ticas


**‚úÖ Insights:** Previs√£o vi√°vel com ¬±15-20% de acur√°cia; possibilita automa√ß√£o operacional por cluster.

---

## üéØ ROADMAP EXECUTIVO (+8-12% UPLIFT POTENCIAL)

| A√ß√£o                        | Prazo    | Impacto   | Prioridade  |
|-----------------------------|----------|-----------|-------------|
| Negociar MDR adquirentes    | 0-15d    | +2-3%     | üî¥ CR√çTICO |
| Ativar dinheiro (9% ‚Üí 12%)  | 0-30d    | +1,5-2%   | üü† ALTO    |
| Precifica√ß√£o din√¢mica +5%   | 30-45d   | +3-5%     | üü† ALTO    |
| Cross-sell noturno          | 15-30d   | +1-2%     | üü° M√âDIO   |
| Automa√ß√£o clusters          | 60+d     | Cont√≠nuo  | üü¢ BAIXO   |


## üèÅ CONCLUS√ÉO FINAL

A an√°lise de vendas da m√°quina de autoatendimento evidencia que a opera√ß√£o √© saud√°vel, com crescimento m√©dio de +5,3% e ticket m√©dio est√°vel. Produtos Classe A (Latte, Americano c/ Leite, Cappuccino e Americano) representam a maior parte da receita, com destaque para oportunidades de cross-sell em itens premium como Hot Chocolate e Cocoa.  

O comportamento do consumidor indica que clientes em dinheiro possuem ticket superior, sugerindo a√ß√µes estrat√©gicas para maximizar receita. A sazonalidade e os feriados impactam fortemente o volume, mas n√£o o ticket, permitindo previsibilidade de abastecimento e planejamento de promo√ß√£o.  

A performance por hor√°rio mostra hor√°rios de pico cr√≠ticos (10h e 12h-17h), enquanto certos per√≠odos e produtos (Espresso, 13h-15h) demandam aten√ß√£o e poss√≠veis ajustes de pre√ßo ou promo√ß√£o.  

A previs√£o de demanda por clusters permite automa√ß√£o operacional e precifica√ß√£o din√¢mica, enquanto o roadmap executivo apresenta a√ß√µes concretas para gerar uplift de 8-12% na receita total.  

**‚úÖ Resumo Estrat√©gico:** Foco em abastecimento cr√≠tico, precifica√ß√£o din√¢mica, ativa√ß√£o de pagamento em dinheiro, cross-sell e automa√ß√£o por cluster permitir√° aumentar receita, melhorar experi√™ncia do cliente e otimizar a opera√ß√£o da m√°quina.
"""